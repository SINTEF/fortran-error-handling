# "template": { "id": "dcmt", "version": 0.9.0 }
################################################################################
################################################################################
# CMake Project Template                                                       #
#                                                                              #
# PLEASE DO NOT EDIT THIS FILE! See cmake-project.json intead                  #
#                                                                              #
################################################################################
################################################################################
cmake_minimum_required(VERSION 3.20 FATAL_ERROR)

################################################################################
# Read project JSON                                                            #
################################################################################
macro(check_parse err)
    if (err)
        message(FATAL_ERROR "Failed to parse project spec: ${err}")
    endif()
endmacro()

file(READ "cmake-project.jsonc" project_json)
set_directory_properties(PROPERTIES CMAKE_CONFIGURE_DEPENDS "cmake-project.jsonc")
string(JSON project_name ERROR_VARIABLE err
    GET ${project_json} "name")
check_parse(${err})
string(JSON project_version ERROR_VARIABLE err
    GET ${project_json} "version")
check_parse(${err})

################################################################################
# Project definition                                                           #
################################################################################
if(EXPECTED_PROJECT_NAME)
    if(NOT project_name STREQUAL EXPECTED_PROJECT_NAME)
        message(FATAL_ERROR "Dependency name mismatch: ${PROJECT_NAME} tried to add dependency ${EXPECTED_PROJECT_NAME}, but the actual name is ${project_name}")
    endif()
endif()
project(${project_name}
    VERSION ${project_version} LANGUAGES NONE)
enable_testing()

# Language specification
string(JSON num_languages ERROR_VARIABLE err
    LENGTH ${project_json} "languages")
if(NOT err)
    math(EXPR n "${num_languages} - 1")
    foreach(i RANGE 0 ${n})
        string(JSON language ERROR_VARIABLE err
            GET ${project_json} "languages" ${i})
        check_parse(${err})
        enable_language(${language})
        if(language STREQUAL "CXX")
            string(JSON cxx_std ERROR_VARIABLE err
                GET ${project_json} "c++std")
            if(err)
                message(WARNING "Language C++ is enabled for project ${project_name}, but 'c++std' is not set. It is reccomended to specify 'c++std' in cmake-project.jsonc")
            endif()
        endif()
    endforeach()
endif()

# Linker language specification
string(JSON linker_language ERROR_VARIABLE err
    GET ${project_json} "linker_language")

# Add debug info to release builds? (for stacktrace generation)
string(JSON release_dbg_info ERROR_VARIABLE err
    GET ${project_json} "release_dbg_info")
if(err)
    set(release_dbg_info False)
endif()

################################################################################
# Root project configuration                                                   #
################################################################################
if(CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)
    # This value will only be propagated to path dependencies so that CPM dependencies
    # using this template can disable tests
    set(is_local True)
else()
    set(is_local False)
endif()

################################################################################
# Compiler flags for this project                                              #
################################################################################
# Any dependency that does not specify compiler flags themselves will also get
# these flags. Presumably that increases chances for compatibility...
# Fortran compiler
if(CMAKE_Fortran_COMPILER_ID MATCHES "GNU")
    set(debug_info_flags "-g")
    # Gfortran's maybe-uninitialized warnings are wildly inaccurate for character
    # strings and thus disabled.
    set(CMAKE_Fortran_FLAGS
        "-fPIC -fbacktrace -fmax-errors=1 -Wall -Wextra -Wimplicit-interface -Wno-maybe-uninitialized -fcoarray=single -ffree-line-length-0")
    set(CMAKE_Fortran_FLAGS_DEBUG "-fcheck=bounds -fcheck=array-temps")
    set(CMAKE_Fortran_FLAGS_RELEASE "-O2 -funroll-loops")
    set(CMAKE_Fortran_FLAGS_RELWITHDEBINFO "${CMAKE_Fortran_FLAGS_RELEASE}")
elseif(CMAKE_Fortran_COMPILER_ID MATCHES "Intel")
    if(WIN32)
        set(debug_info_flags "-Z7")
        set(CMAKE_Fortran_FLAGS
            "-nologo -libs:dll -threads -traceback -fp:precise -align:all -standard-semantics -error-limit:1 -warn:all -nogen-interfaces -Qdiag-disable:5462")
        set(CMAKE_Fortran_FLAGS_DEBUG "-Od -debug:all -dbglibs -check:all -fpe-all:0")
        set(CMAKE_Fortran_FLAGS_RELEASE "-O2")
        set(CMAKE_Fortran_FLAGS_RELWITHDEBINFO "${CMAKE_Fortran_FLAGS_RELEASE} -debug:all")
    else(WIN32)
        set(debug_info_flags "-g")
        set(CMAKE_Fortran_FLAGS
            "-nologo -fPIC -threads -traceback -align all -fp-model precise -pc64 -standard-semantics -error-limit 1 -nogen-interfaces -diag-disable:5462")
        set(CMAKE_Fortran_FLAGS_DEBUG "-O0 -debug -check all -fpe-all=0")
        set(CMAKE_Fortran_FLAGS_RELEASE "-O2")
        set(CMAKE_Fortran_FLAGS_RELWITHDEBINFO "${CMAKE_Fortran_FLAGS_RELEASE} -debug")
    endif(WIN32)
endif()
# Set debug info flags for Fortran
set(CMAKE_Fortran_FLAGS_DEBUG "${debug_info_flags} ${CMAKE_Fortran_FLAGS_DEBUG}")
set(CMAKE_Fortran_FLAGS_RELWITHDEBINFO "${debug_info_flags} ${CMAKE_Fortran_FLAGS_RELWITHDEBINFO}")
if(release_dbg_info)
    set(CMAKE_Fortran_FLAGS_RELEASE "${debug_info_flags} ${CMAKE_Fortran_FLAGS_RELEASE}")
endif()

# C compiler flags
if(CMAKE_C_COMPILER_ID MATCHES "MSVC")
    set(debug_info_flags "-Z7")
    set(CMAKE_C_FLAGS "")
    set(CMAKE_C_FLAGS_RELEASE "-MD -O2")
    set(CMAKE_C_FLAGS_DEBUG "-MDd -Od")
    if(release_dbg_info)
        set(CMAKE_EXE_LINKER_FLAGS "-debug")
    endif()
elseif(CMAKE_C_COMPILER_ID MATCHES "GNU")
    set(debug_info_flags "-g")
    set(CMAKE_C_FLAGS "-fPIC")
    set(CMAKE_C_FLAGS_RELEASE "-O2")
    set(CMAKE_C_FLAGS_DEBUG "-Og")
elseif(CMAKE_C_COMPILER_ID MATCHES "Intel")
    if(WIN32)
        set(debug_info_flags "-Z7")
        set(CMAKE_C_FLAGS "")
        set(CMAKE_C_FLAGS_RELEASE "-MD -O2")
        set(CMAKE_C_FLAGS_DEBUG "-MDd -Od")
        if(release_dbg_info)
            set(CMAKE_EXE_LINKER_FLAGS "-debug")
        endif()
    else()
        set(debug_info_flags "-g")
        set(CMAKE_C_FLAGS "-fPIC")
        set(CMAKE_C_FLAGS_RELEASE "-O2")
        set(CMAKE_C_FLAGS_DEBUG "-O0")
    endif()
endif()
# Set debug info flags for C
set(CMAKE_C_FLAGS_DEBUG "${debug_info_flags} ${CMAKE_C_FLAGS_DEBUG}")
set(CMAKE_C_FLAGS_RELWITHDEBINFO "${debug_info_flags} ${CMAKE_C_FLAGS_RELWITHDEBINFO}")
if(release_dbg_info)
    set(CMAKE_C_FLAGS_RELEASE "${debug_info_flags} ${CMAKE_C_FLAGS_RELEASE}")
endif()

# C++ compiler flags
if(CMAKE_CXX_COMPILER_ID MATCHES "MSVC")
    set(debug_info_flags "-Z7")
    set(CMAKE_CXX_FLAGS "-EHsc")
    set(CMAKE_CXX_FLAGS_RELEASE "-MD -O2")
    set(CMAKE_CXX_FLAGS_DEBUG "-MDd -Od")
    set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELEASE}")
    if(release_dbg_info)
        set(CMAKE_EXE_LINKER_FLAGS "-debug")
    endif()
elseif(CMAKE_CXX_COMPILER_ID MATCHES "GNU")
    set(debug_info_flags "-g")
    set(CMAKE_CXX_FLAGS "-fPIC")
    set(CMAKE_CXX_FLAGS_RELEASE "-O2")
    set(CMAKE_CXX_FLAGS_DEBUG "-Og")
    set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELEASE}")
elseif(CMAKE_CXX_COMPILER_ID MATCHES "Intel")
    if(WIN32)
        set(debug_info_flags "-Z7")
        set(CMAKE_CXX_FLAGS "-Z7")
        set(CMAKE_CXX_FLAGS_RELEASE "-MD -O2")
        set(CMAKE_CXX_FLAGS_DEBUG "-MDd -Od")
        set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELEASE}")
        if(release_dbg_info)
            set(CMAKE_EXE_LINKER_FLAGS "-debug")
        endif()
    else()
        set(debug_info_flags "-g")
        set(CMAKE_CXX_FLAGS "-fPIC")
        set(CMAKE_CXX_FLAGS_RELEASE "-O2")
        set(CMAKE_CXX_FLAGS_DEBUG "-O0")
        set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELEASE}")
    endif()
endif()
# Set debug info flags for C++
set(CMAKE_CXX_FLAGS_DEBUG "${debug_info_flags} ${CMAKE_CXX_FLAGS_DEBUG}")
set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "${debug_info_flags} ${CMAKE_CXX_FLAGS_RELWITHDEBINFO}")
if(release_dbg_info)
    set(CMAKE_CXX_FLAGS_RELEASE "${debug_info_flags} ${CMAKE_CXX_FLAGS_RELEASE}")
endif()

################################################################################
# Add dependencies                                                             #
################################################################################
function(ensure_cpm)
    if(NOT DEFINED CPM_ADDED)
        set(CPM_DOWNLOAD_VERSION 0.34.0)

        if(CPM_SOURCE_CACHE)
            # Expand relative path. This is important if the provided path contains a tilde (~)
            get_filename_component(CPM_SOURCE_CACHE ${CPM_SOURCE_CACHE} ABSOLUTE)
            set(CPM_DOWNLOAD_LOCATION "${CPM_SOURCE_CACHE}/cpm/CPM_${CPM_DOWNLOAD_VERSION}.cmake")
        elseif(DEFINED ENV{CPM_SOURCE_CACHE})
            set(CPM_DOWNLOAD_LOCATION "$ENV{CPM_SOURCE_CACHE}/cpm/CPM_${CPM_DOWNLOAD_VERSION}.cmake")
        else()
            set(CPM_DOWNLOAD_LOCATION "${CMAKE_BINARY_DIR}/cmake/CPM_${CPM_DOWNLOAD_VERSION}.cmake")
        endif()

        if(NOT (EXISTS ${CPM_DOWNLOAD_LOCATION}))
            message(STATUS "Downloading CPM.cmake to ${CPM_DOWNLOAD_LOCATION}")
            file(DOWNLOAD
                https://github.com/cpm-cmake/CPM.cmake/releases/download/v${CPM_DOWNLOAD_VERSION}/CPM.cmake
                ${CPM_DOWNLOAD_LOCATION}
            )
        endif()

        include(${CPM_DOWNLOAD_LOCATION})
        # Enable package locking in root project
        if(CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)
            CPMUsePackageLock(package-lock.cmake)
        endif()
        set(CPM_ADDED True)
    endif()
endfunction()

macro(parse_dependency json i target_list)
    # Unset variables to avoid pollution from parent project
    unset(dep_name)
    unset(dep_git)
    unset(dep_path)
    unset(dep_version)
    unset(dep_tag_type)
    unset(dep_tag)
    unset(dep_path)
    unset(dep_target)

    string(JSON dep_name ERROR_VARIABLE err
        MEMBER ${json} ${i})
    check_parse(${err})
    string(JSON dep_git ERROR_VARIABLE err
        GET ${json} ${dep_name} "git")
    if(err)
        string(JSON dep_path ERROR_VARIABLE err
            GET ${json} ${dep_name} "path")
        if(err)
            string(JSON dep_target ERROR_VARIABLE err
                GET ${json} ${dep_name} "target")
            if(err)
                message(FATAL_ERROR "Unknown dependency type for ${name} (${err})")
            endif()
        endif()
    endif()

    # If dependency uses this template, EXPECTED_PROJECT_NAME is used to verify that
    # dependency name is the same as project name
    set(EXPECTED_PROJECT_NAME "${dep_name}")
    if(dep_git)
        string(JSON dep_version ERROR_VARIABLE err
            GET ${json} ${dep_name} "version")
        check_parse(${err})
        string(JSON dep_tag_type ERROR_VARIABLE err
            TYPE ${json} ${dep_name} "tag")
        if(dep_tag_type)
            string(JSON dep_tag ERROR_VARIABLE err
                GET ${json} ${dep_name} "tag")
            check_parse(${err})
        endif()
        ensure_cpm()
        # Set is_local to False so that other projects using this template can
        # disable tests
        set(is_local_was ${is_local})
        set(is_local False)
        # This will probably need to be a bit more sophisticated in the future...
        if (dep_tag)
            CPMAddPackage(NAME ${dep_name}
                GIT_REPOSITORY ${dep_git}
                VERSION ${dep_version}
                GIT_TAG ${dep_tag}
            )
        else()
            CPMAddPackage(NAME ${dep_name}
                GIT_REPOSITORY ${dep_git}
                VERSION ${dep_version}
            )
        endif()
        if(NOT TARGET "${dep_name}")
            message(FATAL_ERROR "ERROR in project configuration: Dependency ${dep_name} did not add target with same name.")
        endif()
        # Reset is_local for this project
        set(is_local ${is_local_was})
    elseif(dep_path)
        set(dep_binary_path ${CMAKE_CURRENT_BINARY_DIR}/${dep_path})
        cmake_path(RELATIVE_PATH dep_binary_path BASE_DIRECTORY ${CMAKE_BINARY_DIR}
            OUTPUT_VARIABLE dep_root_relative_binary_path)
        string(FIND ${dep_root_relative_binary_path} ".." parent_dir_loc)
        if(parent_dir_loc EQUAL 0)
            # path is outside current project root
            string(REPLACE ".." "__" dep_binary_path ${dep_binary_path})
        endif()
        # Normalize path in-place and make sure it has a trailing slash (for consistency in cache variable)
        cmake_path(NORMAL_PATH dep_binary_path OUTPUT_VARIABLE dep_binary_path)
        if(NOT dep_binary_path MATCHES "\/$")
            set(dep_binary_path "${dep_binary_path}/")
        endif()

        # subdirectories already added by DCMT project are kept track of in DCMT_ADDED_DIRS
        if(NOT dep_binary_path IN_LIST DCMT_ADDED_DIRS)
            list(APPEND DCMT_ADDED_DIRS ${dep_binary_path})
            message(STATUS "Local dependency: Adding ${dep_name} from ${dep_path}")
            if(TARGET "${dep_name}")
                message(FATAL_ERROR "ERROR in project configuration: ${dep_name} is defined as a dependency to ${project_name}, but this target is already defined elsewhere.")
            endif()
            add_subdirectory(${dep_path} ${dep_binary_path})
            if(NOT TARGET "${dep_name}")
                message(FATAL_ERROR "ERROR in project configuration: Dependency ${dep_name} did not add target with same name.")
            endif()
            # Propagate added subdirecotires outwards
            if(NOT CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)
                set(DCMT_ADDED_DIRS ${DCMT_ADDED_DIRS} PARENT_SCOPE)
            endif()
        endif()
    elseif(NOT "${dep_target}" STREQUAL "")
        if(NOT dep_target)
            message(FATAL_ERROR "When 'target' is used for dependency, value must be 'true'")
        endif()
    endif()
    list(APPEND ${target_list} ${dep_name})
    unset(EXPECTED_PROJECT_NAME)
endmacro()

string(JSON num_deps ERROR_VARIABLE err
    LENGTH ${project_json} "dependencies")
if (err)
    set(num_deps 0)
endif()


string(JSON num_dev_deps ERROR_VARIABLE err
    LENGTH ${project_json} "dev-dependencies")
if (err)
    set(num_dev_deps 0)
endif()

# Include CMake Package Manager if project has dependencies
if(num_deps GREATER 0 OR num_dev_deps GREATER 0)
endif()

# Dependencies
if (num_deps GREATER 0)
    string(JSON deps_json ERROR_VARIABLE err
        GET ${project_json} "dependencies")
    check_parse(${err})
    math(EXPR n "${num_deps} - 1")
    foreach(i RANGE 0 ${n})
        parse_dependency(${deps_json} ${i} project_deps)
    endforeach()
endif()

# Dev-dependencies
if (num_dev_deps GREATER 0 AND is_local)
    string(JSON dev_deps_json ERROR_VARIABLE err
        GET ${project_json} "dev-dependencies")
    check_parse(${err})
    math(EXPR n "${num_dev_deps} - 1")
    foreach(i RANGE 0 ${n})
        parse_dependency(${dev_deps_json} ${i} project_dev_deps)
    endforeach()
endif()

################################################################################
# Define library                                                               #
################################################################################
file(GLOB_RECURSE lib_sources CONFIGURE_DEPENDS LIST_DIRECTORIES False "${CMAKE_CURRENT_SOURCE_DIR}/src/*")
if(lib_sources)
    add_library(${project_name} STATIC ${lib_sources})
    target_link_libraries(${project_name} PRIVATE ${project_deps})
    execute_process(COMMAND ${CMAKE_COMMAND} -E make_directory ${CMAKE_CURRENT_BINARY_DIR}/include)
    set_property (TARGET ${project_name}
        PROPERTY Fortran_MODULE_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/include
    )
    target_include_directories(${project_name} PUBLIC ${CMAKE_CURRENT_BINARY_DIR}/include)
    if(DEFINED cxx_std)
        set_property(TARGET ${project_name} PROPERTY CXX_STANDARD ${cxx_std})
    endif()
endif()

################################################################################
# Define applications                                                          #
################################################################################
# FPM supports non-program source files in the app folder. This is impossible to identify
# without a source parser and also a bit confusing layoutwise since there's also a src/ folder.
# Here we assume that all aources in app/ are different programs
file(GLOB_RECURSE app_sources CONFIGURE_DEPENDS LIST_DIRECTORIES False "${CMAKE_CURRENT_SOURCE_DIR}/app/*")
if(app_sources)
    foreach(app_source IN LISTS app_sources)
        get_filename_component(app_name ${app_source} NAME_WE)
        if(app_name STREQUAL "main")
            set(app_name ${project_name})
            # Avoid name collision with library
            set(target_name app-${project_name})
        else()
            set(target_name app-${app_name})
        endif()
        add_executable(${target_name} ${app_source})
        set_target_properties(${target_name} PROPERTIES
            OUTPUT_NAME ${app_name}
            RUNTIME_OUTPUT_DIRECTORY app)
        if(lib_sources)
            target_link_libraries(${target_name} PRIVATE ${project_name})
        endif()
        target_link_libraries(${target_name} PRIVATE ${project_deps})
        if (linker_language)
            set_target_properties(${target_name} PROPERTIES LINKER_LANGUAGE ${linker_language})
        endif()
        if(DEFINED cxx_std)
            set_target_properties(${target_name} PROPERTIES CXX_STANDARD ${cxx_std})
        endif()
    endforeach()
endif()

################################################################################
# Define examples                                                               #
################################################################################
file(GLOB_RECURSE example_sources CONFIGURE_DEPENDS LIST_DIRECTORIES False "${CMAKE_CURRENT_SOURCE_DIR}/example/*")
# Examples are not built if added as a CPM dependency
if(example_sources AND is_local)
    foreach(example_source IN LISTS example_sources)
        get_filename_component(example_name ${example_source} NAME_WE)
        set(target_name example-${example_name})
        add_executable(${target_name} ${example_source})
        set_target_properties(${target_name} PROPERTIES
            OUTPUT_NAME ${example_name}
            RUNTIME_OUTPUT_DIRECTORY example)
        if(lib_sources)
            target_link_libraries(${target_name} PRIVATE ${project_name})
        endif()
        target_link_libraries(${target_name} PRIVATE ${project_deps})
        if (linker_language)
            set_target_properties(${target_name} PROPERTIES LINKER_LANGUAGE ${linker_language})
        endif()
        if(DEFINED cxx_std)
            set_target_properties(${target_name} PROPERTIES CXX_STANDARD ${cxx_std})
        endif()
        # Add example as test requiring a successful execution of it
        add_test(NAME test-${project_name}-example-${example_name}
            COMMAND ${target_name})
    endforeach()
endif()

################################################################################
# Define test                                                                  #
################################################################################
# FPM will create multiple test programs if multiple sources with program blocks are present.
# Here we currently only create one...
file(GLOB_RECURSE test_sources CONFIGURE_DEPENDS LIST_DIRECTORIES False "${CMAKE_CURRENT_SOURCE_DIR}/test/*")
# Tests are not built if added as a CPM dependency
if(test_sources AND is_local)
    # Write runner script to build dir
    set(test_script ${CMAKE_CURRENT_BINARY_DIR}/runtest.cmake)
    file(WRITE ${test_script} "
cmake_minimum_required(VERSION 3.20 FATAL_ERROR)

set(cmd \"\${TEST_EXE} \$ENV{TEST_ARGS}\")
if(DEFINED ENV{TEST_VALGRIND})
    if(DEFINED ENV{TEST_VALGRIND_ARGS})
        set(cmd \"valgrind \$ENV{TEST_VALGRIND_ARGS} \${cmd}\")
    else()
        set(cmd \"valgrind --error-exitcode=1 --leak-check=full \${cmd}\")
    endif()
endif()

message(\"Executing \${cmd}\")
separate_arguments(cmd)
execute_process(COMMAND \${cmd}
    COMMAND_ERROR_IS_FATAL ANY)
    ")
    set(test_target test-${project_name})
    add_executable(${test_target} ${test_sources})
    execute_process(COMMAND ${CMAKE_COMMAND} -E make_directory ${CMAKE_CURRENT_BINARY_DIR}/test-include)
    set_property (TARGET ${test_target}
        PROPERTY Fortran_MODULE_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/test-include
    )
    if(lib_sources)
        target_link_libraries(${test_target} PRIVATE ${project_name})
    endif()
    # project_deps are linked towards project_name with PRIVATE so tests need explicit link towards them to
    # be able to use them as well
    target_link_libraries(${test_target} PRIVATE ${project_deps} ${project_dev_deps})
    # test name prefix may be empty (if CPM dependency). Is used to identify local tests.
    add_test(NAME ${test_target}
        COMMAND ${CMAKE_COMMAND} -DTEST_EXE=$<TARGET_FILE:${test_target}>
             -P${CMAKE_CURRENT_BINARY_DIR}/runtest.cmake)
    if (linker_language)
        set_target_properties(${test_target} PROPERTIES LINKER_LANGUAGE ${linker_language})
    endif()
    if(DEFINED cxx_std)
        set_property(TARGET ${test_target} PROPERTY CXX_STANDARD ${cxx_std})
    endif()
endif()

################################################################################
# User customization (if present)                                              #
################################################################################
set(user_custom_file ${CMAKE_CURRENT_SOURCE_DIR}/project-customization.cmake)
if(EXISTS ${user_custom_file})
    include(${user_custom_file})
endif()
