# "template": { "id": "dcmt", "version": 0.17.0 }
################################################################################
################################################################################
# CMake Project Template                                                       #
#                                                                              #
# PLEASE DO NOT EDIT THIS FILE! See cmake-project.json intead                  #
#                                                                              #
################################################################################
################################################################################
cmake_minimum_required(VERSION 3.20 FATAL_ERROR)

# Check if project is a "local" project or not. Local projects are those projects
# who either is the root project or a project added with the "path" dependency syntax
if(CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)
    set(DCMT_LOCAL_PROJECT True)
elseif(NOT DEFINED DCMT_LOCAL_PROJECT)
    set(DCMT_LOCAL_PROJECT False)
endif()

################################################################################
# Read project JSON                                                            #
################################################################################
macro(check_parse err)
    if (err)
        message(FATAL_ERROR "Failed to parse project spec: ${err}")
    endif()
endmacro()

file(READ "cmake-project.jsonc" project_json)
set_directory_properties(PROPERTIES CMAKE_CONFIGURE_DEPENDS "cmake-project.jsonc")
string(JSON project_name ERROR_VARIABLE err
    GET ${project_json} "name")
check_parse(${err})
string(JSON project_version ERROR_VARIABLE err
    GET ${project_json} "version")
check_parse(${err})

################################################################################
# Project definition                                                           #
################################################################################
if(EXPECTED_PROJECT_NAME)
    if(NOT project_name STREQUAL EXPECTED_PROJECT_NAME)
        message(FATAL_ERROR "Dependency name mismatch: ${PROJECT_NAME} tried to add dependency ${EXPECTED_PROJECT_NAME}, but the actual name is ${project_name}")
    endif()
endif()
project(${project_name}
    VERSION ${project_version} LANGUAGES NONE)
enable_testing()

# Language specification
string(JSON num_languages ERROR_VARIABLE err
    LENGTH ${project_json} "languages")
if(NOT err)
    math(EXPR n "${num_languages} - 1")
    foreach(i RANGE 0 ${n})
        string(JSON language ERROR_VARIABLE err
            GET ${project_json} "languages" ${i})
        check_parse(${err})
        enable_language(${language})
        if(language STREQUAL "CXX")
            string(JSON cxx_std ERROR_VARIABLE err
                GET ${project_json} "c++std")
            if(err)
                message(WARNING "Language C++ is enabled for project ${project_name}, but 'c++std' is not set. It is reccomended to specify 'c++std' in cmake-project.jsonc")
                unset(cxx_std)
            endif()
        endif()
    endforeach()
endif()

# Linker language specification
string(JSON linker_language ERROR_VARIABLE err
    GET ${project_json} "linker-language")

# Add debug info to release builds? (for stacktrace generation)
string(JSON release_dbg_info ERROR_VARIABLE err
    GET ${project_json} "release-dbg-info")
if(err)
    set(release_dbg_info False)
endif()

# Library type (default: static)
string(JSON libtype ERROR_VARIABLE err
    GET ${project_json} "lib-type")
if(err)
    set(libtype STATIC)
else()
    string(TOUPPER "${libtype}" libtype)
endif()

# Settings only relevant if this is main project
if (NOT DEFINED DCMT_STATIC_RUNTIME)
    set(DCMT_STATIC_RUNTIME False)
endif()
if(CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)
    # Compiler runtime libraries (static/dynamic)
    string(JSON runtime ERROR_VARIABLE err
        GET ${project_json} "runtime")
    if(err)
        set(runtime "dynamic")
    endif()
    if (runtime STREQUAL "dynamic")
        set(DCMT_STATIC_RUNTIME False)
        set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>DLL")
    elseif(runtime STREQUAL "static")
        set(DCMT_STATIC_RUNTIME True)
        set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>")
    else()
        message(FATAL_ERROR "Unsupported choice for option 'runtime'. Legal values: static, dynamic")
    endif()
endif()

################################################################################
# Compiler flags for this project                                              #
################################################################################
# Directory to store code coverage data, if enabled
set(codecov_dir "${CMAKE_BINARY_DIR}/code-coverage")
# Any dependency that does not specify compiler flags themselves will also get
# these flags. Presumably that increases chances for compatibility...
# Fortran compiler
# Link flags for executables and shared libraries built in this project
set(link_flags "")
if(CMAKE_Fortran_COMPILER_ID MATCHES "GNU")
    set(debug_info_flags "-g")
    set(fortran_codecov_flags "--coverage -fprofile-abs-path -fprofile-dir=${codecov_dir}")
    if (DCMT_STATIC_RUNTIME)
        list(APPEND link_flags -static-libgfortran -static-libgcc)
    endif()
    # Gfortran's maybe-uninitialized warnings are wildly inaccurate for character
    # strings and thus disabled.
    set(CMAKE_Fortran_FLAGS
        "-fPIC -fbacktrace -fmax-errors=1 -Wall -Wextra -Wimplicit-interface -Wno-maybe-uninitialized -fcoarray=single -ffree-line-length-0")
    set(CMAKE_Fortran_FLAGS_DEBUG "-fcheck=bounds -fcheck=array-temps")
    set(CMAKE_Fortran_FLAGS_RELEASE "-O2 -funroll-loops")
    set(CMAKE_Fortran_FLAGS_RELWITHDEBINFO "${CMAKE_Fortran_FLAGS_RELEASE}")
    set(CMAKE_Fortran_FLAGS_RELWITHCHECKS "${CMAKE_Fortran_FLAGS_RELEASE} -fcheck=bounds -fcheck=array-temps")
elseif(CMAKE_Fortran_COMPILER_ID MATCHES "Intel")
    # Note: This matches both Intel (classic) and IntelLLVM
    if(CMAKE_Fortran_COMPILER_ID STREQUAL "Intel")
        # IntelLLVM does not support code coverage yet
        if (WIN32)
            set(fortran_codecov_flags "-Qprof-gen:srcpos -Qprof-dir:${codecov_dir}")
        else()
            set(fortran_codecov_flags "-prof-gen:srcpos -prof-dir:${codecov_dir}")
        endif()
    endif()
    if(WIN32)
        set(debug_info_flags "-Z7")
        set(CMAKE_Fortran_FLAGS
            "-nologo -libs:dll -threads -traceback -fp:precise -align:all -error-limit:1 -warn:all -nogen-interfaces -Qdiag-disable:5462")
        set(CMAKE_Fortran_FLAGS_DEBUG "-Od -debug:all -dbglibs -check:all")
        set(CMAKE_Fortran_FLAGS_RELEASE "-O2")
        set(CMAKE_Fortran_FLAGS_RELWITHDEBINFO "${CMAKE_Fortran_FLAGS_RELEASE} -debug:all")
        # check stack is disabled as its precense disables optimization
        set(CMAKE_Fortran_FLAGS_RELWITHCHECKS "${CMAKE_Fortran_FLAGS_RELEASE} -check:all -check:nostack -check:noarg_temp_created -fpe:0")
    else()
        if (DCMT_STATIC_RUNTIME)
            list(APPEND link_flags -static-intel -static-libgcc)
        endif()
        set(debug_info_flags "-g")
        set(CMAKE_Fortran_FLAGS
            "-nologo -fPIC -threads -traceback -align all -fp-model precise -pc64 -error-limit 1 -nogen-interfaces -diag-disable:5462")
        set(CMAKE_Fortran_FLAGS_DEBUG "-O0 -debug -check all")
        set(CMAKE_Fortran_FLAGS_RELEASE "-O2")
        set(CMAKE_Fortran_FLAGS_RELWITHDEBINFO "${CMAKE_Fortran_FLAGS_RELEASE} -debug")
        # check stack is disabled as its precense disables optimization
        set(CMAKE_Fortran_FLAGS_RELWITHCHECKS "${CMAKE_Fortran_FLAGS_RELEASE} -check all -check nostack -check noarg_temp_created -fpe=0")
    endif()
endif()
# Set debug info flags for Fortran
set(CMAKE_Fortran_FLAGS_DEBUG "${debug_info_flags} ${CMAKE_Fortran_FLAGS_DEBUG}")
set(CMAKE_Fortran_FLAGS_RELWITHDEBINFO "${debug_info_flags} ${CMAKE_Fortran_FLAGS_RELWITHDEBINFO}")
set(CMAKE_Fortran_FLAGS_RELWITHCHECKS "${debug_info_flags} ${CMAKE_Fortran_FLAGS_RELWITHCHECKS}")
if(release_dbg_info)
    set(CMAKE_Fortran_FLAGS_RELEASE "${debug_info_flags} ${CMAKE_Fortran_FLAGS_RELEASE}")
endif()

# C compiler flags
if(CMAKE_C_COMPILER_ID MATCHES "MSVC")
    # TODO: Code coverage flags
    set(debug_info_flags "-Z7")
    set(CMAKE_C_FLAGS "")
    set(CMAKE_C_FLAGS_RELEASE "-O2")
    set(CMAKE_C_FLAGS_DEBUG "-Od")
    if(release_dbg_info)
        set(CMAKE_EXE_LINKER_FLAGS "-debug")
    endif()
elseif(CMAKE_C_COMPILER_ID MATCHES "GNU")
    set(c_codecov_flags "--coverage -fprofile-abs-path -fprofile-dir=${codecov_dir}")
    set(debug_info_flags "-g")
    set(CMAKE_C_FLAGS "-fPIC -Wall -fmax-errors=1")
    set(CMAKE_C_FLAGS_RELEASE "-O2")
    set(CMAKE_C_FLAGS_DEBUG "-Og")
    if (DCMT_STATIC_RUNTIME)
        list(APPEND link_flags -static-libgcc)
    endif()
elseif(CMAKE_C_COMPILER_ID MATCHES "Clang")
    # TODO: Code coverage flags
    if(WIN32)
        set(debug_info_flags "-g")
        set(CMAKE_C_FLAGS "-Wall -ferror-limit=1")
        set(CMAKE_C_FLAGS_RELEASE "-O2")
        set(CMAKE_C_FLAGS_DEBUG "-Og")
        if(release_dbg_info)
            set(CMAKE_EXE_LINKER_FLAGS "-debug")
        endif()
    else()
        set(debug_info_flags "-g")
        set(CMAKE_C_FLAGS "-fPIC -Wall -ferror-limit=1")
        set(CMAKE_C_FLAGS_RELEASE "-O2")
        set(CMAKE_C_FLAGS_DEBUG "-Og")
    endif()
    set(CMAKE_C_FLAGS_RELWITHDEBINFO "${CMAKE_C_FLAGS_RELEASE}")
elseif(CMAKE_C_COMPILER_ID MATCHES "Intel")
    # Note: This matches both Intel (classic) and IntelLLVM
    if(CMAKE_Fortran_COMPILER_ID STREQUAL "Intel")
        # IntelLLVM does not support code coverage yet
        if (WIN32)
            set(c_codecov_flags "-Qprof-gen:srcpos -Qprof-dir:${codecov_dir}")
        else()
            set(c_codecov_flags "-prof-gen:srcpos -prof-dir:${codecov_dir}")
        endif()
    endif()
    if(WIN32)
        set(debug_info_flags "-Z7")
        set(CMAKE_C_FLAGS "")
        set(CMAKE_C_FLAGS_RELEASE "-MD -O2")
        set(CMAKE_C_FLAGS_DEBUG "-MDd -Od")
        if(release_dbg_info)
            list(APPEND link_flags "-debug")
        endif()
    else()
        set(debug_info_flags "-g")
        set(CMAKE_C_FLAGS "-fPIC")
        set(CMAKE_C_FLAGS_RELEASE "-O2")
        set(CMAKE_C_FLAGS_DEBUG "-O0")
        if (DCMT_STATIC_RUNTIME)
            list(APPEND link_flags -static-libgcc)
        endif()
    endif()
endif()
# Runtime checks are currently set for Fortran code only
set(CMAKE_C_FLAGS_RELWITHCHECKS "")
# Set debug info flags for C
set(CMAKE_C_FLAGS_DEBUG "${debug_info_flags} ${CMAKE_C_FLAGS_DEBUG}")
set(CMAKE_C_FLAGS_RELWITHDEBINFO "${debug_info_flags} ${CMAKE_C_FLAGS_RELWITHDEBINFO}")
set(CMAKE_C_FLAGS_RELWITHCHECKS "${debug_info_flags} ${CMAKE_C_FLAGS_RELWITHCHECKS}")
if(release_dbg_info)
    set(CMAKE_C_FLAGS_RELEASE "${debug_info_flags} ${CMAKE_C_FLAGS_RELEASE}")
endif()

# C++ compiler flags
if(CMAKE_CXX_COMPILER_ID MATCHES "MSVC")
    # TODO: Code coverage flags
    set(debug_info_flags "-Z7")
    set(CMAKE_CXX_FLAGS "-EHsc")
    set(CMAKE_CXX_FLAGS_RELEASE "-O2")
    set(CMAKE_CXX_FLAGS_DEBUG "-Od")
    set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELEASE}")
    if(release_dbg_info)
        set(CMAKE_EXE_LINKER_FLAGS "-debug")
    endif()
elseif(CMAKE_CXX_COMPILER_ID MATCHES "GNU")
    set(debug_info_flags "-g")
    set(cxx_codecov_flags "--coverage -fprofile-abs-path -fprofile-dir=${codecov_dir}")
    set(CMAKE_CXX_FLAGS "-fPIC -Wall -fmax-errors=1")
    set(CMAKE_CXX_FLAGS_RELEASE "-O2")
    set(CMAKE_CXX_FLAGS_DEBUG "-Og")
    set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELEASE}")
    if (DCMT_STATIC_RUNTIME)
        list(APPEND link_flags -static-libstdc++ -static-libgcc)
    endif()
elseif(CMAKE_CXX_COMPILER_ID MATCHES "Clang")
    # TODO: Code coverage flags
    if(WIN32)
        set(debug_info_flags "-g")
        set(CMAKE_C_FLAGS "-Wall -ferror-limit=1")
        set(CMAKE_C_FLAGS_RELEASE "-O2")
        set(CMAKE_C_FLAGS_DEBUG "-Og")
        if(release_dbg_info)
            set(CMAKE_EXE_LINKER_FLAGS "-debug")
        endif()
    else()
        set(debug_info_flags "-g")
        set(CMAKE_C_FLAGS "-fPIC -Wall -ferror-limit=1")
        set(CMAKE_C_FLAGS_RELEASE "-O2")
        set(CMAKE_C_FLAGS_DEBUG "-Og")
    endif()
    set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELEASE}")
elseif(CMAKE_CXX_COMPILER_ID MATCHES "Intel")
    # Note: This matches both Intel (classic) and IntelLLVM
    if(CMAKE_Fortran_COMPILER_ID STREQUAL "Intel")
        # IntelLLVM does not support code coverage yet
        if (WIN32)
            set(cxx_codecov_flags "-Qprof-gen:srcpos -Qprof-dir:${codecov_dir}")
        else()
            set(cxx_codecov_flags "-prof-gen:srcpos -prof-dir:${codecov_dir}")
        endif()
    endif()
    if(WIN32)
        set(debug_info_flags "-Z7")
        set(CMAKE_CXX_FLAGS "-Z7")
        set(CMAKE_CXX_FLAGS_RELEASE "-MD -O2")
        set(CMAKE_CXX_FLAGS_DEBUG "-MDd -Od")
        set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELEASE}")
        if(release_dbg_info)
            list(APPEND link_flags "-debug")
        endif()
    else()
        set(debug_info_flags "-g")
        set(CMAKE_CXX_FLAGS "-fPIC")
        set(CMAKE_CXX_FLAGS_RELEASE "-O2")
        set(CMAKE_CXX_FLAGS_DEBUG "-O0")
        set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELEASE}")
        if (DCMT_STATIC_RUNTIME)
            list(APPEND link_flags -static-libgcc -static-libstdc++)
        endif()
    endif()
endif()
# Runtime checks are currently set for Fortran code only
set(CMAKE_CXX_FLAGS_RELWITHCHECKS "")
# Set debug info flags for C++
set(CMAKE_CXX_FLAGS_DEBUG "${debug_info_flags} ${CMAKE_CXX_FLAGS_DEBUG}")
set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "${debug_info_flags} ${CMAKE_CXX_FLAGS_RELWITHDEBINFO}")
set(CMAKE_CXX_FLAGS_RELWITHCHECKS "${debug_info_flags} ${CMAKE_CXX_FLAGS_RELWITHCHECKS}")
if(release_dbg_info)
    set(CMAKE_CXX_FLAGS_RELEASE "${debug_info_flags} ${CMAKE_CXX_FLAGS_RELEASE}")
endif()

# Optinally enable code coverage
if(DCMT_LOCAL_PROJECT AND CODE_COVERAGE)
    set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} ${fortran_codecov_flags}")
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${c_codecov_flags}")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${cxx_codecov_flags}")
    file(MAKE_DIRECTORY ${codecov_dir})
endif()

################################################################################
# Add dependencies                                                             #
################################################################################
function(ensure_cpm)
    if(NOT DEFINED CPM_ADDED)
        set(CPM_DOWNLOAD_VERSION 0.34.0)

        if(CPM_SOURCE_CACHE)
            # Expand relative path. This is important if the provided path contains a tilde (~)
            get_filename_component(CPM_SOURCE_CACHE ${CPM_SOURCE_CACHE} ABSOLUTE)
            set(CPM_DOWNLOAD_LOCATION "${CPM_SOURCE_CACHE}/cpm/CPM_${CPM_DOWNLOAD_VERSION}.cmake")
        elseif(DEFINED ENV{CPM_SOURCE_CACHE})
            set(CPM_DOWNLOAD_LOCATION "$ENV{CPM_SOURCE_CACHE}/cpm/CPM_${CPM_DOWNLOAD_VERSION}.cmake")
        else()
            set(CPM_DOWNLOAD_LOCATION "${CMAKE_BINARY_DIR}/cmake/CPM_${CPM_DOWNLOAD_VERSION}.cmake")
        endif()

        if(NOT (EXISTS ${CPM_DOWNLOAD_LOCATION}))
            message(STATUS "Downloading CPM.cmake to ${CPM_DOWNLOAD_LOCATION}")
            file(DOWNLOAD
                https://github.com/cpm-cmake/CPM.cmake/releases/download/v${CPM_DOWNLOAD_VERSION}/CPM.cmake
                ${CPM_DOWNLOAD_LOCATION}
            )
        endif()

        include(${CPM_DOWNLOAD_LOCATION})
        # Enable package locking in root project
        if(CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)
            CPMUsePackageLock(package-lock.cmake)
        endif()
        set(CPM_ADDED True)
    endif()
endfunction()

macro(parse_dependency json i target_list)
    # Unset variables to avoid pollution from parent project
    unset(dep_name)
    unset(dep_git)
    unset(dep_path)
    unset(dep_version)
    unset(dep_tag_type)
    unset(dep_tag)
    unset(dep_path)
    unset(dep_target)
    unset(dep_include)
    unset(dep_header_only)

    string(JSON dep_name ERROR_VARIABLE err
        MEMBER ${json} ${i})
    check_parse(${err})
    # Determine dependency type (git, path or target)
    string(JSON dep_git ERROR_VARIABLE err
        GET ${json} ${dep_name} "git")
    if(err)
        string(JSON dep_path ERROR_VARIABLE err
            GET ${json} ${dep_name} "path")
        if(err)
            string(JSON dep_target ERROR_VARIABLE err
                GET ${json} ${dep_name} "target")
            if(err)
                message(FATAL_ERROR "Unknown dependency type for ${name} (${err})")
            endif()
        endif()
    endif()
    # Check if dependency is header only
    set(dep_header_only False)
    string(JSON dep_include ERROR_VARIABLE err
        GET ${json} ${dep_name} "include")
    if(NOT err)
        set(dep_header_only True)
    endif()

    # If dependency uses this template, EXPECTED_PROJECT_NAME is used to verify that
    # dependency name is the same as project name
    set(EXPECTED_PROJECT_NAME "${dep_name}")
    # Current value of DCMT_LOCAL_PROJECT which will be reset after dependency has
    # been added
    set(local_project_was ${DCMT_LOCAL_PROJECT})
    if(dep_git)
        string(JSON dep_version ERROR_VARIABLE err
            GET ${json} ${dep_name} "version")
        check_parse(${err})
        string(JSON dep_tag_type ERROR_VARIABLE err
            TYPE ${json} ${dep_name} "tag")
        if(dep_tag_type)
            string(JSON dep_tag ERROR_VARIABLE err
                GET ${json} ${dep_name} "tag")
            check_parse(${err})
        endif()
        ensure_cpm()
        set(args
            GIT_REPOSITORY ${dep_git}
            VERSION ${dep_version}
        )
        if (dep_tag)
            set(args ${args}
                GIT_TAG ${dep_tag}
            )
        endif()
        if(dep_header_only)
            set(args ${args}
                DOWNLOAD_ONLY True
            )
        endif()
        set(DCMT_LOCAL_PROJECT False)
        CPMAddPackage(NAME ${dep_name} ${args})
        if(NOT dep_header_only AND NOT TARGET "${dep_name}")
            message(FATAL_ERROR "ERROR in project configuration: Dependency ${dep_name} did not add target with same name.")
        endif()
    elseif(dep_path)
        set(dep_binary_path ${CMAKE_CURRENT_BINARY_DIR}/${dep_path})
        cmake_path(RELATIVE_PATH dep_binary_path BASE_DIRECTORY ${CMAKE_BINARY_DIR}
            OUTPUT_VARIABLE dep_root_relative_binary_path)
        string(FIND ${dep_root_relative_binary_path} ".." parent_dir_loc)
        if(parent_dir_loc EQUAL 0)
            # path is outside current project root
            string(REPLACE ".." "__" dep_binary_path ${dep_binary_path})
        endif()
        # Normalize path in-place and make sure it has a trailing slash (for consistency in cache variable)
        cmake_path(NORMAL_PATH dep_binary_path OUTPUT_VARIABLE dep_binary_path)
        if(NOT dep_binary_path MATCHES "\/$")
            set(dep_binary_path "${dep_binary_path}/")
        endif()

        # subdirectories already added by DCMT project are kept track of in DCMT_ADDED_DIRS
        if(NOT dep_binary_path IN_LIST DCMT_ADDED_DIRS)
            list(APPEND DCMT_ADDED_DIRS ${dep_binary_path})
            message(STATUS "Local dependency: Adding ${dep_name} from ${dep_path}")
            if(TARGET "${dep_name}")
                message(FATAL_ERROR "ERROR in project configuration: ${dep_name} is defined as a dependency to ${project_name}, but this target is already defined elsewhere.")
            endif()
            # Make sure subdirectory tests and examples will be included
            set(DCMT_LOCAL_PROJECT True)
            add_subdirectory(${dep_path} ${dep_binary_path})
            if(NOT TARGET "${dep_name}")
                message(FATAL_ERROR "ERROR in project configuration: Dependency ${dep_name} did not add target with same name.")
            endif()
            # Propagate added subdirectories outwards
            if(NOT CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)
                set(DCMT_ADDED_DIRS ${DCMT_ADDED_DIRS} PARENT_SCOPE)
            endif()
        endif()
    elseif(NOT "${dep_target}" STREQUAL "")
        if(NOT dep_target)
            message(FATAL_ERROR "When 'target' is used for dependency, value must be 'true'")
        endif()
    endif()
    if(dep_header_only)
        # Create interface library with specified name
        add_library(${dep_name} INTERFACE)
        target_include_directories(${dep_name} INTERFACE ${${dep_name}_SOURCE_DIR}/${dep_include})
    endif()

    list(APPEND ${target_list} ${dep_name})
    unset(EXPECTED_PROJECT_NAME)
    set(DCMT_LOCAL_PROJECT ${local_project_was})
endmacro()

string(JSON num_deps ERROR_VARIABLE err
    LENGTH ${project_json} "dependencies")
if (err)
    set(num_deps 0)
endif()


string(JSON num_dev_deps ERROR_VARIABLE err
    LENGTH ${project_json} "dev-dependencies")
if (err)
    set(num_dev_deps 0)
endif()

################################################################################
# Add dependencies                                                             #
################################################################################
if (num_deps GREATER 0)
    string(JSON deps_json ERROR_VARIABLE err
        GET ${project_json} "dependencies")
    check_parse(${err})
    math(EXPR n "${num_deps} - 1")
    foreach(i RANGE 0 ${n})
        parse_dependency(${deps_json} ${i} project_deps)
    endforeach()
endif()

################################################################################
# Define library                                                               #
################################################################################
file(GLOB_RECURSE lib_sources CONFIGURE_DEPENDS LIST_DIRECTORIES False "${CMAKE_CURRENT_SOURCE_DIR}/src/*")
if(lib_sources)
    add_library(${project_name} ${libtype} ${lib_sources})
    target_link_libraries(${project_name} PRIVATE ${project_deps})
    execute_process(COMMAND ${CMAKE_COMMAND} -E make_directory ${CMAKE_CURRENT_BINARY_DIR}/include)
    set_property (TARGET ${project_name}
        PROPERTY Fortran_MODULE_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/include
    )
    target_include_directories(${project_name} PUBLIC ${CMAKE_CURRENT_BINARY_DIR}/include)
    target_include_directories(${project_name} PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/src)
    if(DEFINED cxx_std)
        set_property(TARGET ${project_name} PROPERTY CXX_STANDARD ${cxx_std})
    endif()
    if(libtype STREQUAL SHARED)
        target_link_options(${project_name} PRIVATE ${link_flags})
    endif()
endif()

################################################################################
# Define applications                                                          #
################################################################################
# FPM supports non-program source files in the app folder. This is impossible to identify
# without a source parser and also a bit confusing layoutwise since there's also a src/ folder.
# Here we assume that all aources in app/ are different programs
file(GLOB_RECURSE app_sources CONFIGURE_DEPENDS LIST_DIRECTORIES False "${CMAKE_CURRENT_SOURCE_DIR}/app/*")
if(app_sources)
    foreach(app_source IN LISTS app_sources)
        get_filename_component(app_name ${app_source} NAME_WE)
        if(app_name STREQUAL "main")
            set(app_name ${project_name})
            # Avoid name collision with library
            set(target_name app-${project_name})
        else()
            set(target_name app-${app_name})
        endif()
        add_executable(${target_name} ${app_source})
        set_target_properties(${target_name} PROPERTIES
            OUTPUT_NAME ${app_name}
            RUNTIME_OUTPUT_DIRECTORY app)
        if(lib_sources)
            target_link_libraries(${target_name} PRIVATE ${project_name})
        endif()
        target_link_libraries(${target_name} PRIVATE ${project_deps})
        if (linker_language)
            set_target_properties(${target_name} PROPERTIES LINKER_LANGUAGE ${linker_language})
        endif()
        if(DEFINED cxx_std)
            set_target_properties(${target_name} PROPERTIES CXX_STANDARD ${cxx_std})
        endif()
        target_link_options(${target_name} PRIVATE ${link_flags})
    endforeach()
endif()

################################################################################
# Root project only configuration                                              #
################################################################################
# The following configuration will only be run if project is root project or
# if DCMT_LOCAL_PROJECT is set to True. The latter will happen for projects added
# by another DCMT CMakeLists.txt using the path dependency syntax.
# It will not be added when the project is added as a dependency, e.g. through CPM.
# NOTE that project-customization.cmake is included below this section. This is
#      done both when project is root and dependency.
if(DCMT_LOCAL_PROJECT)
    ############################################################################
    # Dev-dependencies                                                         #
    ############################################################################
    if (num_dev_deps GREATER 0)
        string(JSON dev_deps_json ERROR_VARIABLE err
            GET ${project_json} "dev-dependencies")
        check_parse(${err})
        math(EXPR n "${num_dev_deps} - 1")
        foreach(i RANGE 0 ${n})
            parse_dependency(${dev_deps_json} ${i} project_dev_deps)
        endforeach()
    endif()

    ############################################################################
    # Define examples                                                          #
    ############################################################################
    file(GLOB_RECURSE example_sources CONFIGURE_DEPENDS LIST_DIRECTORIES False
        "${CMAKE_CURRENT_SOURCE_DIR}/example/*")
    # Examples are not built if added as a CPM dependency
    if(example_sources)
        foreach(example_source IN LISTS example_sources)
            get_filename_component(example_name ${example_source} NAME_WE)
            set(target_name example-${example_name})
            add_executable(${target_name} ${example_source})
            set_target_properties(${target_name} PROPERTIES
                OUTPUT_NAME ${example_name}
                RUNTIME_OUTPUT_DIRECTORY example)
            if(lib_sources)
                target_link_libraries(${target_name} PRIVATE ${project_name})
            endif()
            target_link_libraries(${target_name} PRIVATE ${project_deps})
            if (linker_language)
                set_target_properties(${target_name} PROPERTIES
                    LINKER_LANGUAGE ${linker_language})
            endif()
            if(DEFINED cxx_std)
                set_target_properties(${target_name} PROPERTIES CXX_STANDARD ${cxx_std})
            endif()
            target_link_options(${target_name} PRIVATE ${link_flags})
            # Add example as test requiring a successful execution of it
            add_test(NAME test-${project_name}-example-${example_name}
                COMMAND ${target_name})
        endforeach()
    endif()
    ############################################################################
    # Define test                                                              #
    ############################################################################
    # FPM will create multiple test programs if multiple sources with program
    # blocks are present. Here we currently only create one...
    file(GLOB_RECURSE test_sources CONFIGURE_DEPENDS LIST_DIRECTORIES False
        "${CMAKE_CURRENT_SOURCE_DIR}/test/*")
    # Tests are not built if added as a CPM dependency
    if(test_sources)
        set(test_target test-${project_name})
        add_executable(${test_target} ${test_sources})
        execute_process(COMMAND ${CMAKE_COMMAND} -E make_directory
            ${CMAKE_CURRENT_BINARY_DIR}/test-include)
        set_property (TARGET ${test_target}
            PROPERTY Fortran_MODULE_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/test-include
        )
        if(lib_sources)
            target_link_libraries(${test_target} PRIVATE ${project_name})
        endif()
        # project_deps are linked towards project_name with PRIVATE so tests need
        # explicit link towards them to be able to use them as well
        target_link_libraries(${test_target} PRIVATE ${project_deps} ${project_dev_deps})
        # test name prefix may be empty (if CPM dependency). Is used to identify local tests.
        add_test(NAME ${test_target} COMMAND ${test_target})
        if (linker_language)
            set_target_properties(${test_target} PROPERTIES
                LINKER_LANGUAGE ${linker_language})
        endif()
        if(DEFINED cxx_std)
            set_property(TARGET ${test_target} PROPERTY CXX_STANDARD ${cxx_std})
        endif()
    endif()
# Done, root only configuration
endif()

################################################################################
# User customization (if present)                                              #
################################################################################
set(user_custom_file ${CMAKE_CURRENT_SOURCE_DIR}/project-customization.cmake)
if(EXISTS ${user_custom_file})
    include(${user_custom_file})
endif()
